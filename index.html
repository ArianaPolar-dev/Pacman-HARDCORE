import React, { useState, useEffect, useRef } from 'react';
import { Trophy, Skull, Timer, RotateCcw, Brain, Target, Zap } from 'lucide-react';

const CELL_SIZE = 20;
const ROWS = 27;
const COLS = 28;
const POWERUP_DURATION = 4000;
const GHOST_BASE_SPEED = 110;
const PACMAN_SPEED = 130;
const GHOST_HUNT_SPEED = 90;
const DANGER_ZONE_RADIUS = 5;

const MAZE = [
  "############################",
  "#............##............#",
  "#.####.#####.##.#####.####.#",
  "#O####.#####.##.#####.####O#",
  "#.####.#####.##.#####.####.#",
  "#..........................#",
  "#.####.##.########.##.####.#",
  "#.####.##.########.##.####.#",
  "#......##....##....##......#",
  "######.##### ## #####.######",
  "######.##### ## #####.######",
  "######.##          ##.######",
  "######.## ######## ##.######",
  "######.## ######## ##.######",
  "      .   ########   .      ",
  "######.## ######## ##.######",
  "######.## ######## ##.######",
  "######.##          ##.######",
  "#............##............#",
  "#.####.#####.##.#####.####.#",
  "#O..##.......  .......##..O#",
  "###.##.##.########.##.##.###",
  "###.##.##.########.##.##.###",
  "#......##....##....##......#",
  "#.##########.##.##########.#",
  "#.##########.##.##########.#",
  "#..........................#",
  "############################"
];

const PacmanGame = () => {
  const [gameState, setGameState] = useState('menu');
  const [pacman, setPacman] = useState({ x: 14, y: 23, dir: 'left' });
  const [ghosts, setGhosts] = useState([]);
  const [pellets, setPellets] = useState([]);
  const [powerups, setPowerups] = useState([]);
  const [score, setScore] = useState(0);
  const [lives, setLives] = useState(3);
  const [powerMode, setPowerMode] = useState(false);
  const [attempts, setAttempts] = useState(0);
  const [startTime, setStartTime] = useState(null);
  const [elapsedTime, setElapsedTime] = useState(0);
  const [winner, setWinner] = useState(null);
  const [playerName, setPlayerName] = useState('');
  const [difficulty, setDifficulty] = useState(1);
  const [dangerZones, setDangerZones] = useState([]);
  
  const lastMoveRef = useRef({ pacman: 0, ghosts: 0 });
  const powerTimeoutRef = useRef(null);
  const playerHistoryRef = useRef([]);
  const strategyMemoryRef = useRef([]);
  const escapeRoutesRef = useRef([]);
  const heatMapRef = useRef({});

  useEffect(() => {
    loadWinner();
  }, []);

  const loadWinner = async () => {
    try {
      const result = await window.storage.get('pacman-brutal-winner', true);
      if (result) {
        setWinner(JSON.parse(result.value));
      }
    } catch (error) {
      console.log('No winner yet');
    }
  };

  const saveWinner = async (name, time, attemptsCount) => {
    const winnerData = { name, time, attempts: attemptsCount, date: new Date().toISOString() };
    try {
      await window.storage.set('pacman-brutal-winner', JSON.stringify(winnerData), true);
      setWinner(winnerData);
    } catch (error) {
      console.error('Error saving winner:', error);
    }
  };

  const initGame = () => {
    const newPellets = [];
    const newPowerups = [];
    
    for (let y = 0; y < ROWS; y++) {
      for (let x = 0; x < COLS; x++) {
        if (MAZE[y][x] === '.') {
          newPellets.push({ x, y });
        } else if (MAZE[y][x] === 'O') {
          newPowerups.push({ x, y });
        }
      }
    }

    const ghostColors = ['#FF0066', '#00FFFF', '#FFB8FF', '#FFB852'];
    const ghostStarts = [
      { x: 13, y: 11 },
      { x: 14, y: 11 },
      { x: 13, y: 13 },
      { x: 14, y: 13 }
    ];

    const personalities = ['hunter', 'ambusher', 'trapper', 'coordinator'];
    
    const newGhosts = ghostStarts.map((pos, i) => ({
      ...pos,
      color: ghostColors[i],
      mode: 'chase',
      target: null,
      personality: personalities[i],
      lastStrategy: null,
      huntMode: false,
      fakeDirection: null,
      trapCooldown: 0
    }));

    setPellets(newPellets);
    setPowerups(newPowerups);
    setGhosts(newGhosts);
    setPacman({ x: 14, y: 23, dir: 'left' });
    setScore(0);
    setLives(3);
    setPowerMode(false);
    setStartTime(Date.now());
    setElapsedTime(0);
    setDangerZones([]);
    playerHistoryRef.current = [];
    heatMapRef.current = {};
  };

  const startGame = () => {
    setGameState('playing');
    setAttempts(prev => prev + 1);
    initGame();
  };

  const resetGame = () => {
    setGameState('menu');
    setAttempts(0);
    setElapsedTime(0);
    strategyMemoryRef.current = [];
  };

  useEffect(() => {
    if (gameState === 'playing') {
      let animationId;
      const gameLoop = (timestamp) => {
        const now = Date.now();
        
        if (now - lastMoveRef.current.pacman >= PACMAN_SPEED) {
          movePacman();
          lastMoveRef.current.pacman = now;
        }
        
        const ghostSpeed = ghosts.some(g => g.huntMode) ? GHOST_HUNT_SPEED : GHOST_BASE_SPEED;
        if (now - lastMoveRef.current.ghosts >= ghostSpeed) {
          moveGhosts();
          updateDangerZones();
          lastMoveRef.current.ghosts = now;
        }

        setElapsedTime(Math.floor((now - startTime) / 1000));
        setDifficulty(Math.min(5, 1 + Math.floor(elapsedTime / 120)));
        
        animationId = requestAnimationFrame(gameLoop);
      };
      
      animationId = requestAnimationFrame(gameLoop);
      return () => cancelAnimationFrame(animationId);
    }
  }, [gameState, pacman, ghosts, pellets, powerups, powerMode, startTime]);

  const isWall = (x, y) => {
    if (y < 0 || y >= ROWS || x < 0 || x >= COLS) return true;
    return MAZE[y][x] === '#';
  };

  const updateHeatMap = (x, y) => {
    const key = `${x},${y}`;
    heatMapRef.current[key] = (heatMapRef.current[key] || 0) + 1;
  };

  const analyzePlayerPattern = () => {
    if (playerHistoryRef.current.length < 10) return null;
    
    const recent = playerHistoryRef.current.slice(-10);
    const moves = [];
    
    for (let i = 1; i < recent.length; i++) {
      const dx = recent[i].x - recent[i-1].x;
      const dy = recent[i].y - recent[i-1].y;
      moves.push({ dx, dy });
    }
    
    const leftTurns = moves.filter((m, i) => i > 0 && 
      (moves[i-1].dx !== 0 && m.dy !== 0) || (moves[i-1].dy !== 0 && m.dx !== 0)
    ).length;
    
    const backtracking = moves.filter((m, i) => i > 0 && 
      m.dx === -moves[i-1].dx && m.dy === -moves[i-1].dy
    ).length;
    
    return {
      turnsOften: leftTurns > 3,
      backtracks: backtracking > 2,
      avgDx: moves.reduce((sum, m) => sum + m.dx, 0) / moves.length,
      avgDy: moves.reduce((sum, m) => sum + m.dy, 0) / moves.length
    };
  };

  const predictMultipleSteps = (steps = 5) => {
    if (playerHistoryRef.current.length < 5) return [];
    
    const pattern = analyzePlayerPattern();
    if (!pattern) return [];
    
    const predictions = [];
    let currentX = pacman.x;
    let currentY = pacman.y;
    
    for (let i = 0; i < steps; i++) {
      currentX += Math.round(pattern.avgDx * (1 + i * 0.2));
      currentY += Math.round(pattern.avgDy * (1 + i * 0.2));
      
      if (!isWall(currentX, currentY)) {
        predictions.push({ x: currentX, y: currentY });
      }
    }
    
    return predictions;
  };

  const findAllEscapeRoutes = (from) => {
    const routes = [];
    const maxDepth = 8;
    
    const explore = (x, y, path, visited) => {
      if (path.length >= maxDepth) {
        routes.push([...path]);
        return;
      }
      
      const moves = [[0, -1], [0, 1], [-1, 0], [1, 0]];
      for (let [dx, dy] of moves) {
        const nx = x + dx;
        const ny = y + dy;
        const key = `${nx},${ny}`;
        
        if (!visited.has(key) && !isWall(nx, ny)) {
          visited.add(key);
          explore(nx, ny, [...path, {x: nx, y: ny}], visited);
          visited.delete(key);
        }
      }
    };
    
    explore(from.x, from.y, [], new Set([`${from.x},${from.y}`]));
    return routes;
  };

  const findSafestRoute = () => {
    const routes = findAllEscapeRoutes(pacman);
    
    if (routes.length === 0) return null;
    
    let safest = routes[0];
    let minDanger = Infinity;
    
    for (let route of routes) {
      let danger = 0;
      for (let pos of route) {
        for (let ghost of ghosts) {
          const dist = Math.abs(pos.x - ghost.x) + Math.abs(pos.y - ghost.y);
          danger += Math.max(0, 10 - dist);
        }
        
        const heatKey = `${pos.x},${pos.y}`;
        danger += (heatMapRef.current[heatKey] || 0) * 2;
      }
      
      if (danger < minDanger) {
        minDanger = danger;
        safest = route;
      }
    }
    
    return safest[Math.min(3, safest.length - 1)];
  };

  const updateDangerZones = () => {
    const zones = [];
    
    for (let ghost of ghosts) {
      if (!powerMode) {
        zones.push({
          x: ghost.x,
          y: ghost.y,
          radius: DANGER_ZONE_RADIUS,
          ghost: ghost
        });
      }
    }
    
    setDangerZones(zones);
  };

  const isInDangerZone = (x, y) => {
    for (let zone of dangerZones) {
      const dist = Math.abs(x - zone.x) + Math.abs(y - zone.y);
      if (dist <= zone.radius) return true;
    }
    return false;
  };

  const findNearestValuableTarget = () => {
    const targets = [...pellets, ...powerups.map(p => ({...p, value: 5}))];
    if (targets.length === 0) return null;
    
    let best = targets[0];
    let bestScore = -Infinity;
    
    for (let target of targets) {
      const dist = Math.abs(pacman.x - target.x) + Math.abs(pacman.y - target.y);
      const danger = isInDangerZone(target.x, target.y) ? 20 : 0;
      const value = target.value || 1;
      const score = value * 10 - dist - danger;
      
      if (score > bestScore) {
        bestScore = score;
        best = target;
      }
    }
    
    return best;
  };

  const movePacman = () => {
    setPacman(prev => {
      const dirs = { up: [0, -1], down: [0, 1], left: [-1, 0], right: [1, 0] };
      const [dx, dy] = dirs[prev.dir] || [0, 0];
      let newX = prev.x + dx;
      let newY = prev.y + dy;

      if (newX < 0) newX = COLS - 1;
      if (newX >= COLS) newX = 0;

      if (isWall(newX, newY)) {
        return prev;
      }

      playerHistoryRef.current.push({ x: newX, y: newY, time: Date.now() });
      if (playerHistoryRef.current.length > 30) {
        playerHistoryRef.current.shift();
      }
      
      updateHeatMap(newX, newY);

      setPellets(currentPellets => {
        const pelletIndex = currentPellets.findIndex(p => p.x === newX && p.y === newY);
        if (pelletIndex !== -1) {
          setScore(s => s + 10);
          const newPellets = [...currentPellets];
          newPellets.splice(pelletIndex, 1);
          
          if (newPellets.length === 0 && !winner) {
            setGameState('won');
            if (playerName.trim()) {
              saveWinner(playerName, elapsedTime, attempts);
            }
          }
          
          return newPellets;
        }
        return currentPellets;
      });

      setPowerups(currentPowerups => {
        const powerupIndex = currentPowerups.findIndex(p => p.x === newX && p.y === newY);
        if (powerupIndex !== -1) {
          setScore(s => s + 50);
          setPowerMode(true);
          if (powerTimeoutRef.current) clearTimeout(powerTimeoutRef.current);
          powerTimeoutRef.current = setTimeout(() => setPowerMode(false), POWERUP_DURATION);
          
          const newPowerups = [...currentPowerups];
          newPowerups.splice(powerupIndex, 1);
          return newPowerups;
        }
        return currentPowerups;
      });

      return { ...prev, x: newX, y: newY };
    });
  };

  const findPath = (start, target, avoidGhosts = false) => {
    const queue = [[start.x, start.y, [], 0]];
    const visited = new Set([`${start.x},${start.y}`]);
    
    while (queue.length > 0) {
      const [x, y, path, cost] = queue.shift();
      
      if (x === target.x && y === target.y) {
        return path;
      }
      
      const moves = [[0, -1], [0, 1], [-1, 0], [1, 0]];
      for (let [dx, dy] of moves) {
        const nx = x + dx;
        const ny = y + dy;
        const key = `${nx},${ny}`;
        
        if (!visited.has(key) && !isWall(nx, ny)) {
          let newCost = cost + 1;
          
          if (avoidGhosts) {
            for (let ghost of ghosts) {
              const dist = Math.abs(nx - ghost.x) + Math.abs(ny - ghost.y);
              if (dist < 3) newCost += 10;
            }
          }
          
          visited.add(key);
          queue.push([nx, ny, [...path, [dx, dy]], newCost]);
        }
      }
      
      if (queue.length > 600) break;
    }
    
    return null;
  };

  const getGhostTarget = (ghost, allGhosts) => {
    if (powerMode) {
      const dx = ghost.x - pacman.x;
      const dy = ghost.y - pacman.y;
      return { 
        x: Math.max(0, Math.min(COLS - 1, ghost.x + dx * 2)),
        y: Math.max(0, Math.min(ROWS - 1, ghost.y + dy * 2))
      };
    }

    const distToPacman = Math.abs(ghost.x - pacman.x) + Math.abs(ghost.y - pacman.y);
    ghost.huntMode = distToPacman < 8;

    const predictions = predictMultipleSteps(8);
    const pattern = analyzePlayerPattern();
    const safestRoute = findSafestRoute();
    const valuableTarget = findNearestValuableTarget();
    
    const pelletsLeft = pellets.length;
    const endgameMode = pelletsLeft < 30;

    switch (ghost.personality) {
      case 'hunter':
        if (predictions.length > 3) {
          const targetIndex = Math.min(5, predictions.length - 1);
          return predictions[targetIndex];
        }
        return pacman;
      
      case 'ambusher':
        if (safestRoute && Math.random() > 0.3) {
          return safestRoute;
        }
        
        if (valuableTarget && distToPacman > 5) {
          return valuableTarget;
        }
        
        const dx = pacman.x - ghost.x;
        const dy = pacman.y - ghost.y;
        return { 
          x: pacman.x + dx * (endgameMode ? 3 : 2), 
          y: pacman.y + dy * (endgameMode ? 3 : 2)
        };
      
      case 'trapper':
        if (ghost.trapCooldown > 0) {
          ghost.trapCooldown--;
        }
        
        if (pattern && pattern.turnsOften && ghost.trapCooldown === 0) {
          ghost.trapCooldown = 20;
          
          const cutoffX = pacman.x + (pattern.avgDx > 0 ? 4 : -4);
          const cutoffY = pacman.y + (pattern.avgDy > 0 ? 4 : -4);
          return { x: cutoffX, y: cutoffY };
        }
        
        if (distToPacman < 4) {
          return pacman;
        }
        
        const nearestPellet = pellets.reduce((nearest, p) => {
          const d = Math.abs(p.x - pacman.x) + Math.abs(p.y - pacman.y);
          const nd = Math.abs(nearest.x - pacman.x) + Math.abs(nearest.y - pacman.y);
          return d < nd ? p : nearest;
        }, pellets[0] || pacman);
        
        return nearestPellet;
      
      case 'coordinator':
        const otherGhosts = allGhosts.filter(g => g.personality !== 'coordinator');
        
        if (otherGhosts.length > 0) {
          const avgX = otherGhosts.reduce((sum, g) => sum + g.x, 0) / otherGhosts.length;
          const avgY = otherGhosts.reduce((sum, g) => sum + g.y, 0) / otherGhosts.length;
          
          const oppositeX = pacman.x + (pacman.x - avgX) * (endgameMode ? 2 : 1.5);
          const oppositeY = pacman.y + (pacman.y - avgY) * (endgameMode ? 2 : 1.5);
          
          return { 
            x: Math.max(0, Math.min(COLS - 1, Math.floor(oppositeX))),
            y: Math.max(0, Math.min(ROWS - 1, Math.floor(oppositeY)))
          };
        }
        
        return pacman;
      
      default:
        return pacman;
    }
  };

  const moveGhosts = () => {
    setGhosts(currentGhosts => {
      return currentGhosts.map(ghost => {
        const target = getGhostTarget(ghost, currentGhosts);
        
        if (Math.random() < 0.15 && !ghost.fakeDirection) {
          const fakes = [[0, -1], [0, 1], [-1, 0], [1, 0]];
          ghost.fakeDirection = fakes[Math.floor(Math.random() * fakes.length)];
          setTimeout(() => { ghost.fakeDirection = null; }, 500);
        }
        
        const moveDir = ghost.fakeDirection || null;
        let path;
        
        if (moveDir) {
          const [dx, dy] = moveDir;
          path = [[dx, dy]];
        } else {
          path = findPath(ghost, target, powerMode);
        }
        
        if (path && path.length > 0) {
          const [dx, dy] = path[0];
          let newX = ghost.x + dx;
          let newY = ghost.y + dy;

          if (newX < 0) newX = COLS - 1;
          if (newX >= COLS) newX = 0;

          if (newX === pacman.x && newY === pacman.y) {
            if (powerMode) {
              setScore(s => s + 200);
              return { 
                ...ghost, 
                x: 13 + (ghost.personality === 'hunter' ? 0 : 1), 
                y: 11,
                huntMode: false
              };
            } else {
              setLives(l => {
                const newLives = l - 1;
                if (newLives <= 0) {
                  setGameState('gameOver');
                }
                return newLives;
              });
              setPacman({ x: 14, y: 23, dir: 'left' });
              return ghost;
            }
          }

          return { ...ghost, x: newX, y: newY };
        }
        
        return ghost;
      });
    });
  };

  useEffect(() => {
    const handleKeyPress = (e) => {
      if (gameState !== 'playing') return;
      
      const key = e.key.toLowerCase();
      if (['arrowup', 'w'].includes(key)) {
        e.preventDefault();
        setPacman(prev => ({ ...prev, dir: 'up' }));
      } else if (['arrowdown', 's'].includes(key)) {
        e.preventDefault();
        setPacman(prev => ({ ...prev, dir: 'down' }));
      } else if (['arrowleft', 'a'].includes(key)) {
        e.preventDefault();
        setPacman(prev => ({ ...prev, dir: 'left' }));
      } else if (['arrowright', 'd'].includes(key)) {
        e.preventDefault();
        setPacman(prev => ({ ...prev, dir: 'right' }));
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [gameState]);

  const formatTime = (seconds) => {
    const h = Math.floor(seconds / 3600);
    const m = Math.floor((seconds % 3600) / 60);
    const s = seconds % 60;
    return `${h}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
  };

  const getDifficultyColor = () => {
    const colors = ['text-yellow-400', 'text-orange-400', 'text-red-400', 'text-purple-400', 'text-pink-400'];
    return colors[Math.min(difficulty - 1, 4)];
  };

  return (
    <div className="flex flex-col items-center justify-center min-h-screen bg-gradient-to-br from-gray-900 via-purple-900 to-black p-4">
      <div className="text-center mb-4">
        <h1 className="text-4xl font-bold text-yellow-400 mb-2 animate-pulse">
          💀 EL PAC-MAN MÁS BRUTAL DEL MUNDO 💀
        </h1>
        {winner && (
          <div className="bg-gradient-to-r from-yellow-400 via-orange-500 to-red-500 text-black px-6 py-3 rounded-lg shadow-lg animate-pulse">
            <Trophy className="inline mr-2" size={24} />
            <span className="font-bold text-xl">🏆 LEYENDA: {winner.name} 🏆</span>
            <span className="ml-4 text-sm">⏱️ {formatTime(winner.time)} | 🎯 {winner.attempts} intentos</span>
          </div>
        )}
      </div>

      {gameState === 'menu' && (
        <div className="bg-gray-800 p-8 rounded-lg shadow-2xl text-center max-w-3xl">
          <Skull className="mx-auto mb-4 text-red-500 animate-bounce" size={80} />
          <h2 className="text-4xl font-bold text-red-500 mb-4">⚠️ ADVERTENCIA EXTREMA ⚠️</h2>
          <div className="text-left text-gray-300 mb-6 space-y-3 bg-gray-900 p-4 rounded">
            <p className="text-yellow-400 font-bold text-lg">🧠 SISTEMAS DE IA BRUTALES:</p>
            <p>🎯 <strong>Predicción Multi-Step</strong> - Calcula tus próximos 8 movimientos</p>
            <p>🔥 <strong>Análisis de Patrones</strong> - Aprende tu estilo y lo contrarresta</p>
            <p>⚡ <strong>Modo Caza Activado</strong> - Se vuelven MÁS RÁPIDOS cuando te detectan</p>
            <p>🕷️ <strong>Coordinación Letal</strong> - 4 fantasmas trabajando como enjambre</p>
            <p>🎭 <strong>Fake-Out Tactics</strong> - Fingen ir en una dirección y cambian</p>
            <p>📊 <strong>Heat Map Analysis</strong> - Memorizan tus rutas favoritas</p>
            <p>🚫 <strong>Bloqueo de Rutas Seguras</strong> - Identifican y cortan tu escape</p>
            <p>🎪 <strong>Dificultad Escalable</strong> - Se vuelven más inteligentes cada 2 minutos</p>
            
            <div className="border-t-2 border-red-500 mt-4 pt-4">
              <p className="text-red-400 font-bold text-xl animate-pulse">
                ⚠️ Este juego es EXTREMADAMENTE DIFÍCIL
              </p>
              <p className="text-gray-400 mt-2">
                Incluso jugadores legendarios como <strong className="text-yellow-400">Billy Mitchell</strong> o{' '}
                <strong className="text-yellow-400">Elijah Johnson</strong> sufrirán.
              </p>
              <p className="text-orange-400 mt-2 font-bold">
                Puede tomar DÍAS de práctica y análisis estratégico para completarlo.
              </p>
            </div>
          </div>
          
          <input
            type="text"
            placeholder="Tu nombre (para inmortalidad si ganas)"
            value={playerName}
            onChange={(e) => setPlayerName(e.target.value)}
            className="w-full px-4 py-3 mb-4 bg-gray-700 text-white rounded border-2 border-red-600 focus:border-yellow-400 focus:outline-none text-lg"
            maxLength={20}
          />
          
          <button
            onClick={startGame}
            className="bg-gradient-to-r from-red-600 to-red-800 hover:from-red-700 hover:to-red-900 text-white font-bold py-4 px-10 rounded-lg text-2xl transition-all transform hover:scale-105 shadow-lg"
          >
            🔥 ACEPTAR EL DESAFÍO 🔥
          </button>
          
          {attempts > 0 && (
            <div className="mt-6 bg-gray-900 p-4 rounded">
              <p className="text-red-400 font-bold text-xl">Has intentado {attempts} veces</p>
              <p className="text-gray-400 text-sm mt-2">La persistencia es clave...</p>
            </div>
          )}
        </div>
      )}

      {gameState === 'playing' && (
        <>
          <div className="flex gap-3 mb-4 text-white flex-wrap justify-center">
            <div className="bg-gray-800 px-4 py-2 rounded shadow-lg">
              Score: <span className="text-yellow-400 font-bold text-xl">{score}</span>
            </div>
            <div className="bg-gray-800 px-4 py-2 rounded shadow-lg">
              Vidas: <span className="text-red-400 font-bold text-xl">{'❤️'.repeat(lives)}</span>
            </div>
            <div className="bg-gray-800 px-4 py-2 rounded flex items-center gap-2 shadow-lg">
              <Timer size={18} className="text-blue-400" />
              <span className="font-bold">{formatTime(elapsedTime)}</span>
            </div>
            <div className="bg-gray-800 px-4 py-2 rounded shadow-lg">
              Intento: <span className="text-purple-400 font-bold">#{attempts}</span>
            </div>
            <div className="bg-gray-800 px-4 py-2 rounded shadow-lg">
              Pellets: <span className="text-green-400 font-bold">{pellets.length}</span>
            </div>
            <div className={`bg-gray-800 px-4 py-2 rounded shadow-lg ${getDifficultyColor()}`}>
              <Brain className="inline mr-1" size={16} />
              <span className="font-bold">IA Nivel {difficulty}</span>
            </div>
          </div>

          <div className="mb-2 flex gap-2 justify-center">
            {ghosts.some(g => g.huntMode) && (
              <div className="bg-red-900 text-white px-4 py-1 rounded-full animate-pulse flex items-center gap-2">
                <Target size={16} />
                <span className="font-bold">¡MODO CAZA ACTIVO!</span>
              </div>
            )}
            {powerMode && (
              <div className="bg-blue-600 text-white px-4 py-1 rounded-full animate-pulse flex items-center gap-2">
                <Zap size={16} />
                <span className="font-bold">PODER TEMPORAL</span>
              </div>
            )}
          </div>

          <div 
            className="relative bg-black border-4 border-blue-600 rounded-lg overflow-hidden shadow-2xl"
            style={{
              width: COLS * CELL_SIZE,
              height: ROWS * CELL_SIZE
            }}
          >
            {MAZE.map((row, y) => 
              row.split('').map((cell, x) => (
                cell === '#' && (
                  <div
                    key={`${x}-${y}`}
                    className="absolute bg-blue-900 border border-blue-700"
                    style={{
                      left: x * CELL_SIZE,
                      top: y * CELL_SIZE,
                      width: CELL_SIZE,
                      height: CELL_SIZE
                    }}
                  />
                )
              ))
            )}

            {dangerZones.map((zone, i) => (
              <div
                key={`danger-${i}`}
                className="absolute bg-red-900 opacity-10 rounded-full pointer-events-none"
                style={{
                  left: (zone.x - zone.radius) * CELL_SIZE,
                  top: (zone.y - zone.radius) * CELL_SIZE,
                  width: zone.radius * 2 * CELL_SIZE,
                  height: zone.radius * 2 * CELL_SIZE
                }}
              />
            ))}

            {pellets.map((pellet, i) => (
              <div
                key={i}
                className="absolute bg-yellow-300 rounded-full"
                style={{
                  left: pellet.x * CELL_SIZE + CELL_SIZE / 2 - 2,
                  top: pellet.y * CELL_SIZE + CELL_SIZE / 2 - 2,
                  width: 4,
                  height: 4
                }}
              />
            ))}

            {powerups.map((powerup, i) => (
              <div
                key={i}
                className="absolute bg-white rounded-full animate-pulse shadow-lg"
                style={{
                  left: powerup.x * CELL_SIZE + CELL_SIZE / 2 - 5,
                  top: powerup.y * CELL_SIZE + CELL_SIZE / 2 - 5,
                  width: 10,
                  height: 10,
                  boxShadow: '0 0 10px #fff'
                }}
              />
            ))}

            <div
              className="absolute text-2xl transition-all duration-100 z-10"
              style={{
                left: pacman.x * CELL_SIZE,
                top: pacman.y * CELL_SIZE,
                width: CELL_SIZE,
                height: CELL_SIZE,
                lineHeight: `${CELL_SIZE}px`,
                textAlign: 'center',
                filter: 'drop-shadow(0 0 3px yellow)'
              }}
            >
              {pacman.dir === 'right' && '😮'}
              {pacman.dir === 'left' && '😲'}
              {pacman.dir === 'up' && '😯'}
              {pacman.dir === 'down' && '😦'}
            </div>

            {ghosts.map((ghost, i) => (
              <div
                key={i}
                className="absolute rounded-full transition-all duration-100"
                style={{
                  left: ghost.x * CELL_SIZE + 2,
                  top: ghost.y * CELL_SIZE + 2,
                  width: CELL_SIZE - 4,
                  height: CELL_SIZE - 4,
                  backgroundColor: powerMode ? '#0066FF' : ghost.color,
                  boxShadow: `0 0 ${ghost.huntMode ? '15px' : '8px'} ${powerMode ? '#0066FF' : ghost.color}`,
                  transform: ghost.huntMode ? 'scale(1.15)' : 'scale(1)',
                  border: ghost.huntMode ? '2px solid #FF0000' : 'none'
                }}
              >
                <div className="text-center text-white text-lg leading-4">
                  {powerMode ? '😱' : ghost.huntMode ? '😈' : '👻'}
                </div>
              </div>
            ))}
          </div>

          <div className="mt-4 text-white text-sm text-center space-y-1">
            <p className="font-bold">🎮 Controles: Flechas o WASD</p>
            {difficulty > 2 && (
              <p className="text-red-400 animate-pulse">⚠️ IA mejorada - Los fantasmas son más inteligentes</p>
            )}
            {pellets.length < 50 && pellets.length > 0 && (
              <p className="text-orange-400 font-bold animate-pulse">
                🚨 ENDGAME - Los fantasmas están desesperados 🚨
              </p>
            )}
          </div>
        </>
      )}

      {gameState === 'gameOver' && (
        <div className="bg-gradient-to-br from-red-900 to-black p-8 rounded-lg shadow-2xl text-center border-4 border-red-600">
          <Skull className="mx-auto mb-4 text-red-500 animate-bounce" size={80} />
          <h2 className="text-4xl font-bold text-red-500 mb-4">💀 DESTRUIDO 💀</h2>
          <div className="text-white space-y-2 mb-6">
            <p className="text-2xl">Score: <span className="text-yellow-400 font-bold">{score}</span></p>
            <p className="text-xl">Tiempo sobrevivido: <span className="text-blue-400 font-bold">{formatTime(elapsedTime)}</span></p>
            <p className="text-xl">Pellets restantes: <span className="text-green-400 font-bold">{pellets.length}</span></p>
            <p className="text-xl">Intento: <span className="text-purple-400 font-bold">#{attempts}</span></p>
            <p className="text-gray-400 mt-4 italic">"La IA te superó esta vez..."</p>
          </div>
          <div className="flex gap-4 justify-center">
            <button
              onClick={startGame}
              className="bg-gradient-to-r from-red-600 to-orange-600 hover:from-red-700 hover:to-orange-700 text-white font-bold py-3 px-8 rounded-lg text-xl transition-all transform hover:scale-105"
            >
              ⚔️ Reintentar
            </button>
            <button
              onClick={resetGame}
              className="bg-gray-700 hover:bg-gray-600 text-white font-bold py-3 px-8 rounded-lg text-xl flex items-center gap-2 transition-all"
            >
              <RotateCcw size={20} />
              Menú
            </button>
          </div>
        </div>
      )}

      {gameState === 'won' && (
        <div className="bg-gradient-to-br from-yellow-300 via-orange-400 to-red-500 p-10 rounded-lg shadow-2xl text-center border-4 border-yellow-600">
          <Trophy className="mx-auto mb-4 text-white animate-bounce" size={100} />
          <h2 className="text-5xl font-bold text-white mb-4 animate-pulse">
            🏆 ¡LEYENDA ABSOLUTA! 🏆
          </h2>
          {!winner && playerName.trim() && (
            <div className="bg-white text-black p-4 rounded-lg mb-4">
              <p className="text-3xl font-bold">🎉 ¡PRIMER GANADOR DE LA HISTORIA! 🎉</p>
              <p className="text-xl mt-2">Tu nombre quedará inmortalizado</p>
            </div>
          )}
          <div className="text-white space-y-3 mb-6 bg-black bg-opacity-30 p-6 rounded-lg">
            <p className="text-3xl font-bold">Score Final: <span className="text-yellow-200">{score}</span></p>
            <p className="text-2xl">⏱️ Tiempo Total: <span className="text-blue-200 font-bold">{formatTime(elapsedTime)}</span></p>
            <p className="text-2xl">🎯 Intentos: <span className="text-purple-200 font-bold">{attempts}</span></p>
            <p className="text-xl mt-4 italic">"Has derrotado a la IA más brutal..."</p>
            <p className="text-2xl mt-4 font-bold animate-pulse">
              👑 ERES UN MAESTRO DEL PAC-MAN 👑
            </p>
          </div>
          <button
            onClick={resetGame}
            className="bg-white text-orange-600 font-bold py-4 px-10 rounded-lg text-2xl hover:bg-gray-100 transition-all transform hover:scale-105 shadow-lg"
          >
            ✨ Volver al Menú ✨
          </button>
        </div>
      )}
      
      <div className="mt-6 text-center text-gray-400 text-xs max-w-2xl">
        <p>💡 Consejos: Los fantasmas aprenden de tus patrones. Varía tu estrategia constantemente.</p>
        <p className="mt-1">El modo poder dura solo {POWERUP_DURATION/1000} segundos. Úsalo sabiamente.</p>
      </div>
    </div>
  );
};

export default PacmanGame;
